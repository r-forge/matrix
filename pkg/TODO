- Migration of lmer from the mer representation to the mer2
   representation and the use of the CHOLMOD code for the sparse
   matrix decomposition.  Some of the things that need to be done.

   - Matrices in the mer2 representation are classed matrices, in the
   mer representation they were unclassed.  Any parts inside the C
   code that would access, for example,
    REAL(GET_SLOT(x, Matrix_RXXSym))
   need to be modified to access
    REAL(GET_SLOT(GET_SLOT(x, Matrix_RXXSym), Matrix_xSym))
   This is especially important for Omega but I think I have done
   those changes already.

   - The components named *X* in an mer object refer to an augmented
   design matrix of p+1 columns.  In the mer2 object there are
   separate slots for rZy and rXy.  The scalar y'y is the first
   element of devComp.

   - Presently nc is of length nf+1 and the last element is n, the
   number of observations.  This value should be moved to devComp and
   nc made of length nf.

   - The slot L is a list of length 1 that contains an ExternalPointer
   to a cholmod_factor object.  This contains a permutation which is
   most easily accessible through cholmod_solve(CHOLMOD_P,...) or
   cholmod_solve(CHOLMOD_Pt,...).  The ZtX, Zty, RZX and rZy slots actually
   contain P%*%RZX and P%*%rZy

------
- Sparse matrix methods can now be based on the CHOLMOD package.  We
   will need to migrate from the current code to CHOLMOD-based code
   using #ifdef USE_CHOLMOD.  Some of the things to be done

   - Move documentation from subdirectories of src to inst/doc
   - Write utilities to create a cholmod_sparse pointer from a
   dgCMatrix or lgCMatrix (or zgCMatrix) object without copying and
   allocating.
   - Start adding simple S4 methods (rcond, %*%, +, cbind, t).

- Report the problem in the Linux ldexp manual page.  The second and
  third calls in the Synopsis should be to ldexpf and ldexpl.

- [,] indexing: for sparse "works", but not yet for negative indices!

- consider moving alloc3Darray from ./src/Mutils.c to
  $(RSRC)/src/base/array.c

-------

- provide methods for "dspMatrix" and "dppMatrix"!

- implement (more) methods for supporting "packed" (symmetric / triangular)
  matrices; particularly something like pack() and unpack()  [to/from our
  classes from/to "numeric"] --- have already man/unpack.Rd but no method yet!

  (have some dtr* <-> dtp*)

- implement diagonal Matrix class  "ddiMatrix" etc
  using constructor function Diagonal() or Diag().

- rcond() of a singular dpoMatrix gives a LaPack error instead of just 0:
  MM <- crossprod(M <- Matrix(c(1:4,9:6), 2,4)) ; rcond(MM)
  ##> Error in rcond(MM) : Lapack routine dpotrf returned error code 4
  It's .Call("dpoMatrix_rcond") --> set_rcond() in src/dpoMatrix.c
  and in src/dppMatrix.c similarly.

  Done(2005-10-03): The error message is more helpful now.

---

- combine the C functions for multiplication by special forms and
  solution wrt special forms by using a 'right' argument and a
  'classed' argument.
   [done with dgeMatrix_matrix_mm();  not yet for other classes;
    and for _crossprod()]

- add more comprehensive examples / tests for Schur decomposition

- arithmetic for sparse matrices:
	     <sparseMatrix>  o  <same-dim-sparseMatrix>
  should return a sparse matrix  for at least "+" and "*" , also %%,
  and "/" and "%/%" at least when the RHS is non-zero a scalar.
  Challenge: nice implementation (``common non-0''; but Tsparse* is not uniq).

---

- Create a Harwell-Boeing version of the matrix mm and the response
  vector y in inst/external and remove them from the data directory.
  Modify any examples that use them and modify the Comparisons vignette.

- "Math2" , "Math", "Arith":
   keep triangular and symmetric Matrices when appropriate:
   particularly desirable for  "Math2": round(), signif()

- "d" <-> "l" coercion for all "[TCR]" sparse matrices is really trivial:
  "d" -> "l" : drops the 'x' slot
  "l" -> "d" : construct an 'x' slot of all '1'
  We currently have many of these conversions explicitly, e.g.
   setAs("dsTMatrix", "lsTMatrix",
      function(from) new("lsTMatrix", i = from@i, j = from@j, uplo = from@uplo,
                         Dim = from@Dim, Dimnames = from@Dimnames))
  but I would rather want to automatically construct all these coercion
  methods at once by a ``method constructor'', i.e.,
  for all  "dsparse*" -> "lsparse*" and vice versa.
  How can one do this {in a documented way} ?
