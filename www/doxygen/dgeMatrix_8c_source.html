<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Matrix: dgeMatrix.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>dgeMatrix.c</h1>  </div>
</div>
<div class="contents">
<a href="dgeMatrix_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="dgeMatrix_8h.html">dgeMatrix.h</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a><a class="code" href="dgeMatrix_8h.html#aeb856bac3027df440d5869db30a27386">00003</a> SEXP <a class="code" href="dgeMatrix_8c.html#aeb856bac3027df440d5869db30a27386">dMatrix_validate</a>(SEXP obj)
<a name="l00004"></a>00004 {
<a name="l00005"></a>00005     SEXP x = GET_SLOT(obj, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>),
<a name="l00006"></a>00006         Dim = GET_SLOT(obj, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>);
<a name="l00007"></a>00007     <span class="keywordtype">int</span> m, n;
<a name="l00008"></a>00008 
<a name="l00009"></a>00009     <span class="keywordflow">if</span> (length(Dim) != 2)
<a name="l00010"></a>00010         <span class="keywordflow">return</span> mkString(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dim slot must have length 2&quot;</span>));
<a name="l00011"></a>00011     m = INTEGER(Dim)[0]; n = INTEGER(Dim)[1];
<a name="l00012"></a>00012     <span class="keywordflow">if</span> (m &lt; 0 || n &lt; 0)
<a name="l00013"></a>00013 <span class="preprocessor">#if defined(R_VERSION) &amp;&amp; R_VERSION &gt;= R_Version(2, 10, 0)</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span>        <span class="keywordflow">return</span> mkString(<a class="code" href="Mutils_8h.html#ac9d549690c7aed53dc608beb710e47bb">dngettext</a>(<span class="stringliteral">&quot;Matrix&quot;</span>,
<a name="l00015"></a>00015                                   <span class="stringliteral">&quot;Negative value in Dim&quot;</span>,
<a name="l00016"></a>00016                                   <span class="stringliteral">&quot;Negative values in Dim&quot;</span>,
<a name="l00017"></a>00017                                   (m*n &gt; 0) ? 2 : 1));
<a name="l00018"></a>00018 <span class="preprocessor">#else</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>        <span class="keywordflow">return</span> mkString(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Negative value(s) in Dim&quot;</span>));
<a name="l00020"></a>00020 <span class="preprocessor">#endif</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!isReal(x))
<a name="l00022"></a>00022         <span class="keywordflow">return</span> mkString(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;x slot must be numeric \&quot;double\&quot;&quot;</span>));
<a name="l00023"></a>00023     <span class="keywordflow">return</span> ScalarLogical(1);
<a name="l00024"></a>00024 }
<a name="l00025"></a>00025 
<a name="l00026"></a><a class="code" href="dgeMatrix_8h.html#af754a26692ba664a4f2559d85bc06f47">00026</a> SEXP <a class="code" href="dgeMatrix_8c.html#af754a26692ba664a4f2559d85bc06f47">dgeMatrix_validate</a>(SEXP obj)
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028     SEXP val,
<a name="l00029"></a>00029         fact = GET_SLOT(obj, <a class="code" href="Syms_8h.html#a4b5b55e9543500874053fafea7b81e52">Matrix_factorSym</a>);
<a name="l00030"></a>00030 
<a name="l00031"></a>00031     <span class="keywordflow">if</span> (isString(val = <a class="code" href="Mutils_8c.html#aad83cbeb5f6e21d7c47da6dd66401cec">dense_nonpacked_validate</a>(obj)))
<a name="l00032"></a>00032         <span class="keywordflow">return</span>(val);
<a name="l00033"></a>00033 
<a name="l00034"></a>00034     <span class="keywordflow">if</span> (length(fact) &gt; 0 &amp;&amp; getAttrib(fact, R_NamesSymbol) == R_NilValue)
<a name="l00035"></a>00035         <span class="keywordflow">return</span> mkString(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;factors slot must be named list&quot;</span>));
<a name="l00036"></a>00036     <span class="keywordflow">return</span> ScalarLogical(1);
<a name="l00037"></a>00037 }
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">static</span>
<a name="l00040"></a><a class="code" href="dgeMatrix_8c.html#a18e14d832081c8d7d6df7bd2f9e390f9">00040</a> <span class="keywordtype">double</span> <a class="code" href="dgeMatrix_8c.html#a18e14d832081c8d7d6df7bd2f9e390f9">get_norm</a>(SEXP obj, <span class="keyword">const</span> <span class="keywordtype">char</span> *typstr)
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042     <span class="keywordflow">if</span>(<a class="code" href="Mutils_8h.html#a30e9ab9c0cdcfcee7a38b82d58deb13c" title="Check if slot(obj, &amp;quot;x&amp;quot;) contains any NA (or NaN).">any_NA_in_x</a>(obj))
<a name="l00043"></a>00043         <span class="keywordflow">return</span> NA_REAL;
<a name="l00044"></a>00044     <span class="keywordflow">else</span> {
<a name="l00045"></a>00045         <span class="keywordtype">char</span> typnm[] = {<span class="charliteral">&#39;\0&#39;</span>, <span class="charliteral">&#39;\0&#39;</span>};
<a name="l00046"></a>00046         <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(obj, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00047"></a>00047         <span class="keywordtype">double</span> *work = (<span class="keywordtype">double</span> *) NULL;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049         typnm[0] = <a class="code" href="Mutils_8c.html#ae83d110234906231be64768d898c866c">La_norm_type</a>(typstr);
<a name="l00050"></a>00050         <span class="keywordflow">if</span> (*typnm == <span class="charliteral">&#39;I&#39;</span>) {
<a name="l00051"></a>00051             work = (<span class="keywordtype">double</span> *) R_alloc(dims[0], <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l00052"></a>00052         }
<a name="l00053"></a>00053         <span class="keywordflow">return</span> F77_CALL(dlange)(typstr, dims, dims+1,
<a name="l00054"></a>00054                                 REAL(GET_SLOT(obj, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)),
<a name="l00055"></a>00055                                 dims, work);
<a name="l00056"></a>00056     }
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="dgeMatrix_8h.html#ad6b2835d2acbc142689c1d980387c5e0">00059</a> SEXP <a class="code" href="dgeMatrix_8c.html#a92c375aa96724a587d26c2f83f2daab5">dgeMatrix_norm</a>(SEXP obj, SEXP type)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061     <span class="keywordflow">return</span> ScalarReal(<a class="code" href="dgeMatrix_8c.html#a18e14d832081c8d7d6df7bd2f9e390f9">get_norm</a>(obj, CHAR(asChar(type))));
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="dgeMatrix_8h.html#ac4f1b4b19a004fb62c9cb68ccb1028ea">00064</a> SEXP <a class="code" href="dgeMatrix_8c.html#ac4f1b4b19a004fb62c9cb68ccb1028ea">dgeMatrix_rcond</a>(SEXP obj, SEXP type)
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066     SEXP LU = PROTECT(<a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(obj, FALSE));<span class="comment">/* &lt;- not warning about singularity */</span>
<a name="l00067"></a>00067     <span class="keywordtype">char</span> typnm[] = {<span class="charliteral">&#39;\0&#39;</span>, <span class="charliteral">&#39;\0&#39;</span>};
<a name="l00068"></a>00068     <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(LU, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)), info;
<a name="l00069"></a>00069     <span class="keywordtype">double</span> anorm, rcond;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     <span class="keywordflow">if</span> (dims[0] != dims[1] || dims[0] &lt; 1) {
<a name="l00072"></a>00072         UNPROTECT(1);
<a name="l00073"></a>00073         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;rcond requires a square, non-empty matrix&quot;</span>));
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075     typnm[0] = <a class="code" href="Mutils_8c.html#a646ee60a4fb346b69460858856a4a5a2">La_rcond_type</a>(CHAR(asChar(type)));
<a name="l00076"></a>00076     anorm = <a class="code" href="dgeMatrix_8c.html#a18e14d832081c8d7d6df7bd2f9e390f9">get_norm</a>(obj, typnm);
<a name="l00077"></a>00077     F77_CALL(dgecon)(typnm,
<a name="l00078"></a>00078                      dims, REAL(GET_SLOT(LU, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)),
<a name="l00079"></a>00079                      dims, &amp;anorm, &amp;rcond,
<a name="l00080"></a>00080                      (<span class="keywordtype">double</span> *) R_alloc(4*dims[0], <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)),
<a name="l00081"></a>00081                      (<span class="keywordtype">int</span> *) R_alloc(dims[0], <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)), &amp;info);
<a name="l00082"></a>00082     UNPROTECT(1);
<a name="l00083"></a>00083     <span class="keywordflow">return</span> ScalarReal(rcond);
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="dgeMatrix_8h.html#a1d6cfeb6b881161af7296a438c4bf1b3">00086</a> SEXP <a class="code" href="dgeMatrix_8c.html#a1d6cfeb6b881161af7296a438c4bf1b3">dgeMatrix_crossprod</a>(SEXP x, SEXP trans)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     <span class="keywordtype">int</span> tr = asLogical(trans);<span class="comment">/* trans=TRUE: tcrossprod(x) */</span>
<a name="l00089"></a>00089     SEXP val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;dpoMatrix&quot;</span>))),
<a name="l00090"></a>00090         nms = VECTOR_ELT(GET_SLOT(x, <a class="code" href="Syms_8h.html#a93d8b8a3cd9c897599b3e2d996821a0b">Matrix_DimNamesSym</a>), tr ? 0 : 1),
<a name="l00091"></a>00091         vDnms = <a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a93d8b8a3cd9c897599b3e2d996821a0b">Matrix_DimNamesSym</a>, VECSXP, 2);
<a name="l00092"></a>00092     <span class="keywordtype">int</span> *Dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00093"></a>00093         *vDims = INTEGER(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>, INTSXP, 2));
<a name="l00094"></a>00094     <span class="keywordtype">int</span> k = tr ? Dims[1] : Dims[0], n = tr ? Dims[0] : Dims[1];
<a name="l00095"></a>00095     <span class="keywordtype">double</span> *vx = REAL(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, REALSXP, n * n)),
<a name="l00096"></a>00096         one = 1.0, zero = 0.0;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     <a class="code" href="Mutils_8h.html#a8388ab26cceddaa6efaccc3c51add430">AZERO</a>(vx, n * n);
<a name="l00099"></a>00099     SET_SLOT(val, <a class="code" href="Syms_8h.html#ac4fa9962123be6abbeaf9c7219b62644">Matrix_uploSym</a>, mkString(<span class="stringliteral">&quot;U&quot;</span>));
<a name="l00100"></a>00100     <a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a4b5b55e9543500874053fafea7b81e52">Matrix_factorSym</a>, VECSXP, 0);
<a name="l00101"></a>00101     vDims[0] = vDims[1] = n;
<a name="l00102"></a>00102     SET_VECTOR_ELT(vDnms, 0, duplicate(nms));
<a name="l00103"></a>00103     SET_VECTOR_ELT(vDnms, 1, duplicate(nms));
<a name="l00104"></a>00104     <span class="keywordflow">if</span>(n)
<a name="l00105"></a>00105     F77_CALL(dsyrk)(<span class="stringliteral">&quot;U&quot;</span>, tr ? <span class="stringliteral">&quot;N&quot;</span> : <span class="stringliteral">&quot;T&quot;</span>, &amp;n, &amp;k,
<a name="l00106"></a>00106                     &amp;one, REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), Dims,
<a name="l00107"></a>00107                     &amp;zero, vx, &amp;n);
<a name="l00108"></a>00108     SET_SLOT(val, <a class="code" href="Syms_8h.html#a4b5b55e9543500874053fafea7b81e52">Matrix_factorSym</a>, allocVector(VECSXP, 0));
<a name="l00109"></a>00109     UNPROTECT(1);
<a name="l00110"></a>00110     <span class="keywordflow">return</span> val;
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="dgeMatrix_8h.html#a49aa50c9ebf93d2eb2b83395c4709161">00113</a> SEXP <a class="code" href="dgeMatrix_8c.html#a49aa50c9ebf93d2eb2b83395c4709161">dgeMatrix_dgeMatrix_crossprod</a>(SEXP x, SEXP y, SEXP trans)
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115     <span class="keywordtype">int</span> tr = asLogical(trans);<span class="comment">/* trans=TRUE: tcrossprod(x,y) */</span>
<a name="l00116"></a>00116     SEXP val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;dgeMatrix&quot;</span>)));
<a name="l00117"></a>00117     <span class="keywordtype">int</span> *xDims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00118"></a>00118         *yDims = INTEGER(GET_SLOT(y, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00119"></a>00119         *vDims;
<a name="l00120"></a>00120     <span class="keywordtype">int</span> m  = xDims[!tr],  n = yDims[!tr];<span class="comment">/* -&gt; result dim */</span>
<a name="l00121"></a>00121     <span class="keywordtype">int</span> xd = xDims[ tr], yd = yDims[ tr];<span class="comment">/* the conformable dims */</span>
<a name="l00122"></a>00122     <span class="keywordtype">double</span> one = 1.0, zero = 0.0;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     SET_SLOT(val, <a class="code" href="Syms_8h.html#a4b5b55e9543500874053fafea7b81e52">Matrix_factorSym</a>, allocVector(VECSXP, 0));
<a name="l00125"></a>00125     SET_SLOT(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>, allocVector(INTSXP, 2));
<a name="l00126"></a>00126     vDims = INTEGER(GET_SLOT(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00127"></a>00127     <span class="keywordflow">if</span> (xd &gt; 0 &amp;&amp; yd &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; m &gt; 0) {
<a name="l00128"></a>00128         <span class="keywordflow">if</span> (xd != yd)
<a name="l00129"></a>00129             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dimensions of x and y are not compatible for %s&quot;</span>),
<a name="l00130"></a>00130                   tr ? <span class="stringliteral">&quot;tcrossprod&quot;</span> : <span class="stringliteral">&quot;crossprod&quot;</span>);
<a name="l00131"></a>00131         vDims[0] = m; vDims[1] = n;
<a name="l00132"></a>00132         SET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, allocVector(REALSXP, m * n));
<a name="l00133"></a>00133         F77_CALL(dgemm)(tr ? <span class="stringliteral">&quot;N&quot;</span> : <span class="stringliteral">&quot;T&quot;</span>, tr ? <span class="stringliteral">&quot;T&quot;</span> : <span class="stringliteral">&quot;N&quot;</span>, &amp;m, &amp;n, &amp;xd, &amp;one,
<a name="l00134"></a>00134                         REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), xDims,
<a name="l00135"></a>00135                         REAL(GET_SLOT(y, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), yDims,
<a name="l00136"></a>00136                         &amp;zero, REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;m);
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     UNPROTECT(1);
<a name="l00139"></a>00139     <span class="keywordflow">return</span> val;
<a name="l00140"></a>00140 }
<a name="l00141"></a>00141 
<a name="l00142"></a><a class="code" href="dgeMatrix_8h.html#a81810f4f6dc67a5e62babde744317a01">00142</a> SEXP <a class="code" href="dgeMatrix_8c.html#a81810f4f6dc67a5e62babde744317a01">dgeMatrix_matrix_crossprod</a>(SEXP x, SEXP y, SEXP trans)
<a name="l00143"></a>00143 {
<a name="l00144"></a>00144     <span class="keywordtype">int</span> tr = asLogical(trans);<span class="comment">/* trans=TRUE: tcrossprod(x,y) */</span>
<a name="l00145"></a>00145     SEXP val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;dgeMatrix&quot;</span>)));
<a name="l00146"></a>00146     <span class="keywordtype">int</span> *xDims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00147"></a>00147         *yDims = INTEGER(getAttrib(y, R_DimSymbol)),
<a name="l00148"></a>00148         *vDims, nprot = 1;
<a name="l00149"></a>00149     <span class="keywordtype">int</span> m  = xDims[!tr],  n = yDims[!tr];<span class="comment">/* -&gt; result dim */</span>
<a name="l00150"></a>00150     <span class="keywordtype">int</span> xd = xDims[ tr], yd = yDims[ tr];<span class="comment">/* the conformable dims */</span>
<a name="l00151"></a>00151     <span class="keywordtype">double</span> one = 1.0, zero = 0.0;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="keywordflow">if</span> (isInteger(y)) {
<a name="l00154"></a>00154         y = PROTECT(coerceVector(y, REALSXP));
<a name="l00155"></a>00155         nprot++;
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (!(isMatrix(y) &amp;&amp; isReal(y)))
<a name="l00158"></a>00158         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument y must be a numeric matrix&quot;</span>));
<a name="l00159"></a>00159     SET_SLOT(val, <a class="code" href="Syms_8h.html#a4b5b55e9543500874053fafea7b81e52">Matrix_factorSym</a>, allocVector(VECSXP, 0));
<a name="l00160"></a>00160     SET_SLOT(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>, allocVector(INTSXP, 2));
<a name="l00161"></a>00161     vDims = INTEGER(GET_SLOT(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00162"></a>00162     <span class="keywordflow">if</span> (xd &gt; 0 &amp;&amp; yd &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; m &gt; 0) {
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (xd != yd)
<a name="l00164"></a>00164             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dimensions of x and y are not compatible for %s&quot;</span>),
<a name="l00165"></a>00165                   tr ? <span class="stringliteral">&quot;tcrossprod&quot;</span> : <span class="stringliteral">&quot;crossprod&quot;</span>);
<a name="l00166"></a>00166         vDims[0] = m; vDims[1] = n;
<a name="l00167"></a>00167         SET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, allocVector(REALSXP, m * n));
<a name="l00168"></a>00168         F77_CALL(dgemm)(tr ? <span class="stringliteral">&quot;N&quot;</span> : <span class="stringliteral">&quot;T&quot;</span>, tr ? <span class="stringliteral">&quot;T&quot;</span> : <span class="stringliteral">&quot;N&quot;</span>, &amp;m, &amp;n, &amp;xd, &amp;one,
<a name="l00169"></a>00169                         REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), xDims,
<a name="l00170"></a>00170                         REAL(y), yDims,
<a name="l00171"></a>00171                         &amp;zero, REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;m);
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173     UNPROTECT(nprot);
<a name="l00174"></a>00174     <span class="keywordflow">return</span> val;
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="dgeMatrix_8h.html#a6b7001e9250c8c936b4b1cf618122fa8">00178</a> SEXP <a class="code" href="dgeMatrix_8c.html#a6b7001e9250c8c936b4b1cf618122fa8">dgeMatrix_getDiag</a>(SEXP x)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180 <span class="preprocessor">#define geMatrix_getDiag_1                                      \</span>
<a name="l00181"></a>00181 <span class="preprocessor">    int *dims = INTEGER(GET_SLOT(x, Matrix_DimSym));            \</span>
<a name="l00182"></a>00182 <span class="preprocessor">    int i, m = dims[0], nret = (m &lt; dims[1]) ? m : dims[1];     \</span>
<a name="l00183"></a>00183 <span class="preprocessor">    SEXP x_x = GET_SLOT(x, Matrix_xSym)</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>
<a name="l00185"></a>00185     geMatrix_getDiag_1;
<a name="l00186"></a>00186     SEXP ret = PROTECT(allocVector(REALSXP, nret));
<a name="l00187"></a>00187     <span class="keywordtype">double</span> *rv = REAL(ret),
<a name="l00188"></a>00188            *xv = REAL(x_x);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="preprocessor">#define geMatrix_getDiag_2                      \</span>
<a name="l00191"></a>00191 <span class="preprocessor">    for (i = 0; i &lt; nret; i++) {                \</span>
<a name="l00192"></a>00192 <span class="preprocessor">        rv[i] = xv[i * (m + 1)];                \</span>
<a name="l00193"></a>00193 <span class="preprocessor">    }                                           \</span>
<a name="l00194"></a>00194 <span class="preprocessor">    UNPROTECT(1);                               \</span>
<a name="l00195"></a>00195 <span class="preprocessor">    return ret</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span>
<a name="l00197"></a>00197     geMatrix_getDiag_2;
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 
<a name="l00200"></a><a class="code" href="dgeMatrix_8h.html#adb2a7402a88c7d3850973384269dc467">00200</a> SEXP <a class="code" href="dgeMatrix_8c.html#adb2a7402a88c7d3850973384269dc467">lgeMatrix_getDiag</a>(SEXP x)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202     geMatrix_getDiag_1;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     SEXP ret = PROTECT(allocVector(LGLSXP, nret));
<a name="l00205"></a>00205     <span class="keywordtype">int</span> *rv = LOGICAL(ret),
<a name="l00206"></a>00206         *xv = LOGICAL(x_x);
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     geMatrix_getDiag_2;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="preprocessor">#undef geMatrix_getDiag_1</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="preprocessor">#undef geMatrix_getDiag_2</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00214"></a>00214 
<a name="l00215"></a><a class="code" href="dgeMatrix_8h.html#a25fac53ee67024e89f6240deaa4c7ca3">00215</a> SEXP <a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(SEXP x, Rboolean warn_sing)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217     SEXP val = <a class="code" href="Mutils_8c.html#ac8a9910ab35d85d32c6801477c2e6622">get_factors</a>(x, <span class="stringliteral">&quot;LU&quot;</span>);
<a name="l00218"></a>00218     <span class="keywordtype">int</span> *dims, npiv, info;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="keywordflow">if</span> (val != R_NilValue) <span class="comment">/* nothing to do if it&#39;s there in &#39;factors&#39; slot */</span>
<a name="l00221"></a>00221         <span class="keywordflow">return</span> val;
<a name="l00222"></a>00222     dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (dims[0] &lt; 1 || dims[1] &lt; 1)
<a name="l00224"></a>00224         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot factor a matrix with zero extents&quot;</span>));
<a name="l00225"></a>00225     npiv = (dims[0] &lt;dims[1]) ? dims[0] : dims[1];
<a name="l00226"></a>00226     val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;denseLU&quot;</span>)));
<a name="l00227"></a>00227     <a class="code" href="Mutils_8h.html#a36a9a730e1a12cbe017064fe140aefd2">slot_dup</a>(val, x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>);
<a name="l00228"></a>00228     <a class="code" href="Mutils_8h.html#a36a9a730e1a12cbe017064fe140aefd2">slot_dup</a>(val, x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>);
<a name="l00229"></a>00229     F77_CALL(dgetrf)(dims, dims + 1, REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)),
<a name="l00230"></a>00230                      dims,
<a name="l00231"></a>00231                      INTEGER(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a1e4c56ea9d2e084e0cb7154bcc13e196">Matrix_permSym</a>, INTSXP, npiv)),
<a name="l00232"></a>00232                      &amp;info);
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (info &lt; 0)
<a name="l00234"></a>00234         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Lapack routine %s returned error code %d&quot;</span>), <span class="stringliteral">&quot;dgetrf&quot;</span>, info);
<a name="l00235"></a>00235     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (info &gt; 0 &amp;&amp; warn_sing)
<a name="l00236"></a>00236         warning(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Exact singularity detected during LU decomposition.&quot;</span>));
<a name="l00237"></a>00237     UNPROTECT(1);
<a name="l00238"></a>00238     <span class="keywordflow">return</span> <a class="code" href="Mutils_8c.html#acb9e30480c757f0c780a5d94853b7284">set_factors</a>(x, val, <span class="stringliteral">&quot;LU&quot;</span>);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="dgeMatrix_8h.html#a14710a79940dbc67cab89dc8c302c210">00241</a> SEXP <a class="code" href="dgeMatrix_8c.html#a14710a79940dbc67cab89dc8c302c210">dgeMatrix_LU</a>(SEXP x, SEXP warn_singularity)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243     <span class="keywordflow">return</span> <a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(x, asLogical(warn_singularity));
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00246"></a><a class="code" href="dgeMatrix_8h.html#aebb502aae0db4698b17a88c6c0f0ec39">00246</a> SEXP <a class="code" href="dgeMatrix_8c.html#aebb502aae0db4698b17a88c6c0f0ec39">dgeMatrix_determinant</a>(SEXP x, SEXP logarithm)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248     <span class="keywordtype">int</span> lg = asLogical(logarithm);
<a name="l00249"></a>00249     <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00250"></a>00250         n = dims[0], sign = 1;
<a name="l00251"></a>00251     <span class="keywordtype">double</span> modulus = lg ? 0. : 1; <span class="comment">/* initialize; = result for n == 0 */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     <span class="keywordflow">if</span> (n != dims[1])
<a name="l00254"></a>00254         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Determinant requires a square matrix&quot;</span>));
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (n &gt; 0) {
<a name="l00256"></a>00256         SEXP lu = <a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(x, <span class="comment">/* do not warn about singular LU: */</span> FALSE);
<a name="l00257"></a>00257         <span class="keywordtype">int</span> i, *jpvt = INTEGER(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a1e4c56ea9d2e084e0cb7154bcc13e196">Matrix_permSym</a>));
<a name="l00258"></a>00258         <span class="keywordtype">double</span> *luvals = REAL(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>));
<a name="l00259"></a>00259 
<a name="l00260"></a>00260         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) <span class="keywordflow">if</span> (jpvt[i] != (i + 1)) sign = -sign;
<a name="l00261"></a>00261         <span class="keywordflow">if</span> (lg) {
<a name="l00262"></a>00262             <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l00263"></a>00263                 <span class="keywordtype">double</span> dii = luvals[i*(n + 1)]; <span class="comment">/* ith diagonal element */</span>
<a name="l00264"></a>00264                 modulus += log(dii &lt; 0 ? -dii : dii);
<a name="l00265"></a>00265                 <span class="keywordflow">if</span> (dii &lt; 0) sign = -sign;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267         } <span class="keywordflow">else</span> {
<a name="l00268"></a>00268             <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00269"></a>00269                 modulus *= luvals[i*(n + 1)];
<a name="l00270"></a>00270             <span class="keywordflow">if</span> (modulus &lt; 0) {
<a name="l00271"></a>00271                 modulus = -modulus;
<a name="l00272"></a>00272                 sign = -sign;
<a name="l00273"></a>00273             }
<a name="l00274"></a>00274         }
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276     <span class="keywordflow">return</span> <a class="code" href="Mutils_8c.html#a11d1c1bc4eec273005b5a2a340db9f78">as_det_obj</a>(modulus, lg, sign);
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a><a class="code" href="dgeMatrix_8h.html#a8f0564cd095a4415738ef1ad8d537da1">00279</a> SEXP <a class="code" href="dgeMatrix_8c.html#a8f0564cd095a4415738ef1ad8d537da1">dgeMatrix_solve</a>(SEXP a)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281     <span class="comment">/*  compute the 1-norm of the matrix, which is needed</span>
<a name="l00282"></a>00282 <span class="comment">        later for the computation of the reciprocal condition number. */</span>
<a name="l00283"></a>00283     <span class="keywordtype">double</span> aNorm = <a class="code" href="dgeMatrix_8c.html#a18e14d832081c8d7d6df7bd2f9e390f9">get_norm</a>(a, <span class="stringliteral">&quot;1&quot;</span>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">/* the LU decomposition : */</span>
<a name="l00286"></a>00286     SEXP val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;dgeMatrix&quot;</span>))),
<a name="l00287"></a>00287         lu = <a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(a, TRUE);
<a name="l00288"></a>00288     <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00289"></a>00289         *pivot = INTEGER(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a1e4c56ea9d2e084e0cb7154bcc13e196">Matrix_permSym</a>));
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="comment">/* prepare variables for the dgetri calls */</span>
<a name="l00292"></a>00292     <span class="keywordtype">double</span> *x, tmp;
<a name="l00293"></a>00293     <span class="keywordtype">int</span> info, lwork = -1;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="keywordflow">if</span> (dims[0] != dims[1]) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Solve requires a square matrix&quot;</span>));
<a name="l00297"></a>00297     <a class="code" href="Mutils_8h.html#a36a9a730e1a12cbe017064fe140aefd2">slot_dup</a>(val, lu, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>);
<a name="l00298"></a>00298     x = REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>));
<a name="l00299"></a>00299     <a class="code" href="Mutils_8h.html#a36a9a730e1a12cbe017064fe140aefd2">slot_dup</a>(val, lu, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="keywordflow">if</span>(dims[0]) <span class="comment">/* the dimension is not zero */</span>
<a name="l00302"></a>00302     {
<a name="l00303"></a>00303         <span class="comment">/* is the matrix is *computationally* singular ? */</span>
<a name="l00304"></a>00304         <span class="keywordtype">double</span> rcond;
<a name="l00305"></a>00305         F77_CALL(dgecon)(<span class="stringliteral">&quot;1&quot;</span>, dims, x, dims, &amp;aNorm, &amp;rcond,
<a name="l00306"></a>00306                          (<span class="keywordtype">double</span> *) R_alloc(4*dims[0], <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)),
<a name="l00307"></a>00307                          (<span class="keywordtype">int</span> *) R_alloc(dims[0], <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)), &amp;info);
<a name="l00308"></a>00308         <span class="keywordflow">if</span> (info)
<a name="l00309"></a>00309             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;error [%d] from Lapack &#39;dgecon()&#39;&quot;</span>), info);
<a name="l00310"></a>00310         <span class="keywordflow">if</span>(rcond &lt; DOUBLE_EPS)
<a name="l00311"></a>00311             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Lapack dgecon(): system computationally singular, reciprocal condition number = %g&quot;</span>),
<a name="l00312"></a>00312                   rcond);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="comment">/* only now try the inversion and check if the matrix is *exactly* singular: */</span>
<a name="l00315"></a>00315         F77_CALL(dgetri)(dims, x, dims, pivot, &amp;tmp, &amp;lwork, &amp;info);
<a name="l00316"></a>00316         lwork = (int) tmp;
<a name="l00317"></a>00317         F77_CALL(dgetri)(dims, x, dims, pivot,
<a name="l00318"></a>00318                          (<span class="keywordtype">double</span> *) R_alloc((<span class="keywordtype">size_t</span>) lwork, <span class="keyword">sizeof</span>(double)),
<a name="l00319"></a>00319                          &amp;lwork, &amp;info);
<a name="l00320"></a>00320         <span class="keywordflow">if</span> (info)
<a name="l00321"></a>00321             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Lapack routine dgetri: system is exactly singular&quot;</span>));
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323     UNPROTECT(1);
<a name="l00324"></a>00324     <span class="keywordflow">return</span> val;
<a name="l00325"></a>00325 }
<a name="l00326"></a>00326 
<a name="l00327"></a><a class="code" href="dgeMatrix_8h.html#a4aaf5ed4d71841560a06e2eda9da3762">00327</a> SEXP <a class="code" href="dgeMatrix_8c.html#a4aaf5ed4d71841560a06e2eda9da3762">dgeMatrix_matrix_solve</a>(SEXP a, SEXP b)
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329     SEXP val = PROTECT(<a class="code" href="Mutils_8c.html#a574d0797f3bfb4cb555038c8d90cceb8">dup_mMatrix_as_dgeMatrix</a>(b)),
<a name="l00330"></a>00330         lu = PROTECT(<a class="code" href="dgeMatrix_8c.html#a25fac53ee67024e89f6240deaa4c7ca3">dgeMatrix_LU_</a>(a, TRUE));
<a name="l00331"></a>00331     <span class="keywordtype">int</span> *adims = INTEGER(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00332"></a>00332         *bdims = INTEGER(GET_SLOT(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00333"></a>00333     <span class="keywordtype">int</span> info, n = bdims[0], nrhs = bdims[1];
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="keywordflow">if</span> (*adims != *bdims || bdims[1] &lt; 1 || *adims &lt; 1 || *adims != adims[1])
<a name="l00336"></a>00336         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dimensions of system to be solved are inconsistent&quot;</span>));
<a name="l00337"></a>00337     F77_CALL(dgetrs)(<span class="stringliteral">&quot;N&quot;</span>, &amp;n, &amp;nrhs, REAL(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;n,
<a name="l00338"></a>00338                      INTEGER(GET_SLOT(lu, <a class="code" href="Syms_8h.html#a1e4c56ea9d2e084e0cb7154bcc13e196">Matrix_permSym</a>)),
<a name="l00339"></a>00339                      REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;n, &amp;info);
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (info)
<a name="l00341"></a>00341         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Lapack routine dgetrs: system is exactly singular&quot;</span>));
<a name="l00342"></a>00342     UNPROTECT(2);
<a name="l00343"></a>00343     <span class="keywordflow">return</span> val;
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a><a class="code" href="dgeMatrix_8h.html#acf21cab0cdce9d8e08d40584cbe0647c">00346</a> SEXP <a class="code" href="dgeMatrix_8c.html#aea29b77b767799e6bc4976e36b53579d">dgeMatrix_matrix_mm</a>(SEXP a, SEXP bP, SEXP right)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348     SEXP b = PROTECT(<a class="code" href="Mutils_8h.html#a460951a1f5dadb579d977ba114eec12e">mMatrix_as_dgeMatrix</a>(bP)),
<a name="l00349"></a>00349         val = PROTECT(NEW_OBJECT(MAKE_CLASS(<span class="stringliteral">&quot;dgeMatrix&quot;</span>)));
<a name="l00350"></a>00350     <span class="keywordtype">int</span> *adims = INTEGER(GET_SLOT(a, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00351"></a>00351         *bdims = INTEGER(GET_SLOT(b, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>)),
<a name="l00352"></a>00352         *cdims = INTEGER(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>, INTSXP, 2));
<a name="l00353"></a>00353     <span class="keywordtype">double</span> one = 1., zero = 0.;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     <span class="keywordflow">if</span> (asLogical(right)) {
<a name="l00356"></a>00356         <span class="keywordtype">int</span> m = bdims[0], n = adims[1], k = bdims[1];
<a name="l00357"></a>00357         <span class="keywordflow">if</span> (adims[0] != k)
<a name="l00358"></a>00358             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Matrices are not conformable for multiplication&quot;</span>));
<a name="l00359"></a>00359         cdims[0] = m; cdims[1] = n;
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (m &lt; 1 || n &lt; 1 || k &lt; 1) {
<a name="l00361"></a>00361 <span class="comment">/*          error(_(&quot;Matrices with zero extents cannot be multiplied&quot;)); */</span>
<a name="l00362"></a>00362             <a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, REALSXP, m * n);
<a name="l00363"></a>00363         } <span class="keywordflow">else</span>
<a name="l00364"></a>00364             F77_CALL(dgemm) (<span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, &amp;m, &amp;n, &amp;k, &amp;one,
<a name="l00365"></a>00365                              REAL(GET_SLOT(b, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;m,
<a name="l00366"></a>00366                              REAL(GET_SLOT(a, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;k, &amp;zero,
<a name="l00367"></a>00367                              REAL(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, REALSXP, m * n)),
<a name="l00368"></a>00368                              &amp;m);
<a name="l00369"></a>00369     } <span class="keywordflow">else</span> {
<a name="l00370"></a>00370         <span class="keywordtype">int</span> m = adims[0], n = bdims[1], k = adims[1];
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         <span class="keywordflow">if</span> (bdims[0] != k)
<a name="l00373"></a>00373             error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Matrices are not conformable for multiplication&quot;</span>));
<a name="l00374"></a>00374         cdims[0] = m; cdims[1] = n;
<a name="l00375"></a>00375         <span class="keywordflow">if</span> (m &lt; 1 || n &lt; 1 || k &lt; 1) {
<a name="l00376"></a>00376 <span class="comment">/*          error(_(&quot;Matrices with zero extents cannot be multiplied&quot;)); */</span>
<a name="l00377"></a>00377             <a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, REALSXP, m * n);
<a name="l00378"></a>00378         } <span class="keywordflow">else</span>
<a name="l00379"></a>00379             F77_CALL(dgemm)
<a name="l00380"></a>00380                 (<span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, &amp;m, &amp;n, &amp;k, &amp;one, REAL(GET_SLOT(a, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)),
<a name="l00381"></a>00381                  &amp;m, REAL(GET_SLOT(b, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), &amp;k, &amp;zero,
<a name="l00382"></a>00382                  REAL(<a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>, REALSXP, m * n)), &amp;m);
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384     <a class="code" href="Mutils_8h.html#af7f59236ca18ab52131cf71f4a7b0786" title="Allocate an SEXP of given type and length, assign it as slot nm in the object, and return the SEXP...">ALLOC_SLOT</a>(val, <a class="code" href="Syms_8h.html#a93d8b8a3cd9c897599b3e2d996821a0b">Matrix_DimNamesSym</a>, VECSXP, 2);
<a name="l00385"></a>00385     UNPROTECT(2);
<a name="l00386"></a>00386     <span class="keywordflow">return</span> val;
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00390"></a><a class="code" href="dgeMatrix_8h.html#a474be2197aa1bf3e0c7a7ebea3721d2b">00390</a> SEXP <a class="code" href="dgeMatrix_8c.html#a75a5b78c53e3ed08e245685f655348a0">dgeMatrix_svd</a>(SEXP x, SEXP nnu, SEXP nnv)
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392     <span class="keywordtype">int</span> <span class="comment">/* nu = asInteger(nnu),</span>
<a name="l00393"></a>00393 <span class="comment">           nv = asInteger(nnv), */</span>
<a name="l00394"></a>00394         *dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00395"></a>00395     <span class="keywordtype">double</span> *xx = REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>));
<a name="l00396"></a>00396     SEXP val = PROTECT(allocVector(VECSXP, 3));
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (dims[0] &amp;&amp; dims[1]) {
<a name="l00399"></a>00399         <span class="keywordtype">int</span> m = dims[0], n = dims[1], mm = (m &lt; n)?m:n,
<a name="l00400"></a>00400             lwork = -1, info;
<a name="l00401"></a>00401         <span class="keywordtype">double</span> tmp, *work;
<a name="l00402"></a>00402         <span class="keywordtype">int</span> *iwork = <a class="code" href="Mutils_8h.html#a679ceea530c97713d6abdb619e70a6b9">Alloca</a>(8 * mm, <span class="keywordtype">int</span>);
<a name="l00403"></a>00403         R_CheckStack();
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         SET_VECTOR_ELT(val, 0, allocVector(REALSXP, mm));
<a name="l00406"></a>00406         SET_VECTOR_ELT(val, 1, allocMatrix(REALSXP, m, mm));
<a name="l00407"></a>00407         SET_VECTOR_ELT(val, 2, allocMatrix(REALSXP, mm, n));
<a name="l00408"></a>00408         F77_CALL(<a class="code" href="dgeMatrix_8h.html#a82816694a7a62efa0b4cff7a16ec27a9">dgesdd</a>)(<span class="stringliteral">&quot;S&quot;</span>, &amp;m, &amp;n, xx, &amp;m,
<a name="l00409"></a>00409                          REAL(VECTOR_ELT(val, 0)),
<a name="l00410"></a>00410                          REAL(VECTOR_ELT(val, 1)), &amp;m,
<a name="l00411"></a>00411                          REAL(VECTOR_ELT(val, 2)), &amp;mm,
<a name="l00412"></a>00412                          &amp;tmp, &amp;lwork, iwork, &amp;info);
<a name="l00413"></a>00413         lwork = (int) tmp;
<a name="l00414"></a>00414         work = <a class="code" href="Mutils_8h.html#a679ceea530c97713d6abdb619e70a6b9">Alloca</a>(lwork, <span class="keywordtype">double</span>);
<a name="l00415"></a>00415         R_CheckStack();
<a name="l00416"></a>00416         F77_CALL(<a class="code" href="dgeMatrix_8h.html#a82816694a7a62efa0b4cff7a16ec27a9">dgesdd</a>)(<span class="stringliteral">&quot;S&quot;</span>, &amp;m, &amp;n, xx, &amp;m,
<a name="l00417"></a>00417                          REAL(VECTOR_ELT(val, 0)),
<a name="l00418"></a>00418                          REAL(VECTOR_ELT(val, 1)), &amp;m,
<a name="l00419"></a>00419                          REAL(VECTOR_ELT(val, 2)), &amp;mm,
<a name="l00420"></a>00420                          work, &amp;lwork, iwork, &amp;info);
<a name="l00421"></a>00421 
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423     UNPROTECT(1);
<a name="l00424"></a>00424     <span class="keywordflow">return</span> val;
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a><a class="code" href="dgeMatrix_8c.html#a1e92887dad9596ede92506cbef17b506">00427</a> <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="dgeMatrix_8c.html#a1e92887dad9596ede92506cbef17b506">padec</a> [] = <span class="comment">/* for matrix exponential calculation. */</span>
<a name="l00428"></a>00428 {
<a name="l00429"></a>00429   5.0000000000000000e-1,
<a name="l00430"></a>00430   1.1666666666666667e-1,
<a name="l00431"></a>00431   1.6666666666666667e-2,
<a name="l00432"></a>00432   1.6025641025641026e-3,
<a name="l00433"></a>00433   1.0683760683760684e-4,
<a name="l00434"></a>00434   4.8562548562548563e-6,
<a name="l00435"></a>00435   1.3875013875013875e-7,
<a name="l00436"></a>00436   1.9270852604185938e-9,
<a name="l00437"></a>00437 };
<a name="l00438"></a>00438 
<a name="l00446"></a><a class="code" href="dgeMatrix_8h.html#a8bb1459b2c5c175a2aba80bb94202a35">00446</a> SEXP <a class="code" href="dgeMatrix_8c.html#a8bb1459b2c5c175a2aba80bb94202a35" title="Matrix exponential - based on the _corrected_ code for Octave&amp;#39;s expm function.">dgeMatrix_exp</a>(SEXP x)
<a name="l00447"></a>00447 {
<a name="l00448"></a>00448     <span class="keyword">const</span> <span class="keywordtype">double</span> one = 1.0, zero = 0.0;
<a name="l00449"></a>00449     <span class="keyword">const</span> <span class="keywordtype">int</span> i1 = 1;
<a name="l00450"></a>00450     <span class="keywordtype">int</span> *Dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00451"></a>00451     <span class="keyword">const</span> <span class="keywordtype">int</span> n = Dims[1], nsqr = n * n, np1 = n + 1;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     SEXP val = PROTECT(duplicate(x));
<a name="l00454"></a>00454     <span class="keywordtype">int</span> i, ilo, ilos, ihi, ihis, j, sqpow;
<a name="l00455"></a>00455     <span class="keywordtype">int</span> *pivot = Calloc(n, <span class="keywordtype">int</span>);
<a name="l00456"></a>00456     <span class="keywordtype">double</span> *dpp = Calloc(nsqr, <span class="keywordtype">double</span>), <span class="comment">/* denominator power Pade&#39; */</span>
<a name="l00457"></a>00457         *npp = Calloc(nsqr, <span class="keywordtype">double</span>), <span class="comment">/* numerator power Pade&#39; */</span>
<a name="l00458"></a>00458         *perm = Calloc(n, <span class="keywordtype">double</span>),
<a name="l00459"></a>00459         *scale = Calloc(n, <span class="keywordtype">double</span>),
<a name="l00460"></a>00460         *v = REAL(GET_SLOT(val, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)),
<a name="l00461"></a>00461         *work = Calloc(nsqr, <span class="keywordtype">double</span>), inf_norm, m1_j<span class="comment">/*= (-1)^j */</span>, trshift;
<a name="l00462"></a>00462     R_CheckStack();
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="keywordflow">if</span> (n &lt; 1 || Dims[0] != n)
<a name="l00465"></a>00465         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Matrix exponential requires square, non-null matrix&quot;</span>));
<a name="l00466"></a>00466     <span class="keywordflow">if</span>(n == 1) {
<a name="l00467"></a>00467         v[0] = exp(v[0]);
<a name="l00468"></a>00468         UNPROTECT(1);
<a name="l00469"></a>00469         <span class="keywordflow">return</span> val;
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472     <span class="comment">/* Preconditioning 1.  Shift diagonal by average diagonal if positive. */</span>
<a name="l00473"></a>00473     trshift = 0;                <span class="comment">/* determine average diagonal element */</span>
<a name="l00474"></a>00474     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) trshift += v[i * np1];
<a name="l00475"></a>00475     trshift /= n;
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (trshift &gt; 0.) {         <span class="comment">/* shift diagonal by -trshift */</span>
<a name="l00477"></a>00477         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) v[i * np1] -= trshift;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="comment">/* Preconditioning 2. Balancing with dgebal. */</span>
<a name="l00481"></a>00481     F77_CALL(dgebal)(<span class="stringliteral">&quot;P&quot;</span>, &amp;n, v, &amp;n, &amp;ilo, &amp;ihi, perm, &amp;j);
<a name="l00482"></a>00482     <span class="keywordflow">if</span> (j) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_exp: LAPACK routine dgebal returned %d&quot;</span>), j);
<a name="l00483"></a>00483     F77_CALL(dgebal)(<span class="stringliteral">&quot;S&quot;</span>, &amp;n, v, &amp;n, &amp;ilos, &amp;ihis, scale, &amp;j);
<a name="l00484"></a>00484     <span class="keywordflow">if</span> (j) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_exp: LAPACK routine dgebal returned %d&quot;</span>), j);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486     <span class="comment">/* Preconditioning 3. Scaling according to infinity norm */</span>
<a name="l00487"></a>00487     inf_norm = F77_CALL(dlange)(<span class="stringliteral">&quot;I&quot;</span>, &amp;n, &amp;n, v, &amp;n, work);
<a name="l00488"></a>00488     sqpow = (inf_norm &gt; 0) ? (<span class="keywordtype">int</span>) (1 + log(inf_norm)/log(2.)) : 0;
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (sqpow &lt; 0) sqpow = 0;
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (sqpow &gt; 0) {
<a name="l00491"></a>00491         <span class="keywordtype">double</span> scale_factor = 1.0;
<a name="l00492"></a>00492         <span class="keywordflow">for</span> (i = 0; i &lt; sqpow; i++) scale_factor *= 2.;
<a name="l00493"></a>00493         <span class="keywordflow">for</span> (i = 0; i &lt; nsqr; i++) v[i] /= scale_factor;
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="comment">/* Pade&#39; approximation. Powers v^8, v^7, ..., v^1 */</span>
<a name="l00497"></a>00497     <a class="code" href="Mutils_8h.html#a8388ab26cceddaa6efaccc3c51add430">AZERO</a>(npp, nsqr);
<a name="l00498"></a>00498     <a class="code" href="Mutils_8h.html#a8388ab26cceddaa6efaccc3c51add430">AZERO</a>(dpp, nsqr);
<a name="l00499"></a>00499     m1_j = -1;
<a name="l00500"></a>00500     <span class="keywordflow">for</span> (j = 7; j &gt;=0; j--) {
<a name="l00501"></a>00501         <span class="keywordtype">double</span> mult = <a class="code" href="dgeMatrix_8c.html#a1e92887dad9596ede92506cbef17b506">padec</a>[j];
<a name="l00502"></a>00502         <span class="comment">/* npp = m * npp + padec[j] *m */</span>
<a name="l00503"></a>00503         F77_CALL(dgemm)(<span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, &amp;n, &amp;n, &amp;n, &amp;one, v, &amp;n, npp, &amp;n,
<a name="l00504"></a>00504                         &amp;zero, work, &amp;n);
<a name="l00505"></a>00505         <span class="keywordflow">for</span> (i = 0; i &lt; nsqr; i++) npp[i] = work[i] + mult * v[i];
<a name="l00506"></a>00506         <span class="comment">/* dpp = m * dpp + (m1_j * padec[j]) * m */</span>
<a name="l00507"></a>00507         mult *= m1_j;
<a name="l00508"></a>00508         F77_CALL(dgemm)(<span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, &amp;n, &amp;n, &amp;n, &amp;one, v, &amp;n, dpp, &amp;n,
<a name="l00509"></a>00509                         &amp;zero, work, &amp;n);
<a name="l00510"></a>00510         <span class="keywordflow">for</span> (i = 0; i &lt; nsqr; i++) dpp[i] = work[i] + mult * v[i];
<a name="l00511"></a>00511         m1_j *= -1;
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     <span class="comment">/* Zero power */</span>
<a name="l00514"></a>00514     <span class="keywordflow">for</span> (i = 0; i &lt; nsqr; i++) dpp[i] *= -1.;
<a name="l00515"></a>00515     <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l00516"></a>00516         npp[j * np1] += 1.;
<a name="l00517"></a>00517         dpp[j * np1] += 1.;
<a name="l00518"></a>00518     }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     <span class="comment">/* Pade&#39; approximation is solve(dpp, npp) */</span>
<a name="l00521"></a>00521     F77_CALL(dgetrf)(&amp;n, &amp;n, dpp, &amp;n, pivot, &amp;j);
<a name="l00522"></a>00522     <span class="keywordflow">if</span> (j) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_exp: dgetrf returned error code %d&quot;</span>), j);
<a name="l00523"></a>00523     F77_CALL(dgetrs)(<span class="stringliteral">&quot;N&quot;</span>, &amp;n, &amp;n, dpp, &amp;n, pivot, npp, &amp;n, &amp;j);
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (j) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_exp: dgetrs returned error code %d&quot;</span>), j);
<a name="l00525"></a>00525     Memcpy(v, npp, nsqr);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527     <span class="comment">/* Now undo all of the preconditioning */</span>
<a name="l00528"></a>00528     <span class="comment">/* Preconditioning 3: square the result for every power of 2 */</span>
<a name="l00529"></a>00529     <span class="keywordflow">while</span> (sqpow--) {
<a name="l00530"></a>00530         F77_CALL(dgemm)(<span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, &amp;n, &amp;n, &amp;n, &amp;one, v, &amp;n, v, &amp;n,
<a name="l00531"></a>00531                         &amp;zero, work, &amp;n);
<a name="l00532"></a>00532         Memcpy(v, work, nsqr);
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534     <span class="comment">/* Preconditioning 2: apply inverse scaling */</span>
<a name="l00535"></a>00535     <span class="keywordflow">for</span> (j = 0; j &lt; n; j++)
<a name="l00536"></a>00536         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00537"></a>00537             v[i + j * n] *= scale[i]/scale[j];
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">/* 2 b) Inverse permutation  (if not the identity permutation) */</span>
<a name="l00541"></a>00541     <span class="keywordflow">if</span> (ilo != 1 || ihi != n) {
<a name="l00542"></a>00542         <span class="comment">/* Martin Maechler&#39;s code */</span>
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="preprocessor">#define SWAP_ROW(I,J) F77_CALL(dswap)(&amp;n, &amp;v[(I)], &amp;n, &amp;v[(J)], &amp;n)</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span>
<a name="l00546"></a>00546 <span class="preprocessor">#define SWAP_COL(I,J) F77_CALL(dswap)(&amp;n, &amp;v[(I)*n], &amp;i1, &amp;v[(J)*n], &amp;i1)</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>
<a name="l00548"></a>00548 <span class="preprocessor">#define RE_PERMUTE(I)                           \</span>
<a name="l00549"></a>00549 <span class="preprocessor">        int p_I = (int) (perm[I]) - 1;          \</span>
<a name="l00550"></a>00550 <span class="preprocessor">        SWAP_COL(I, p_I);                       \</span>
<a name="l00551"></a>00551 <span class="preprocessor">        SWAP_ROW(I, p_I)</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>
<a name="l00553"></a>00553         <span class="comment">/* reversion of &quot;leading permutations&quot; : in reverse order */</span>
<a name="l00554"></a>00554         <span class="keywordflow">for</span> (i = (ilo - 1) - 1; i &gt;= 0; i--) {
<a name="l00555"></a>00555             <a class="code" href="dgeMatrix_8c.html#a4d96109456cb4306feff10cde2588833">RE_PERMUTE</a>(i);
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="comment">/* reversion of &quot;trailing permutations&quot; : applied in forward order */</span>
<a name="l00559"></a>00559         <span class="keywordflow">for</span> (i = (ihi + 1) - 1; i &lt; n; i++) {
<a name="l00560"></a>00560             <a class="code" href="dgeMatrix_8c.html#a4d96109456cb4306feff10cde2588833">RE_PERMUTE</a>(i);
<a name="l00561"></a>00561         }
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     <span class="comment">/* Preconditioning 1: Trace normalization */</span>
<a name="l00565"></a>00565     <span class="keywordflow">if</span> (trshift &gt; 0.) {
<a name="l00566"></a>00566         <span class="keywordtype">double</span> mult = exp(trshift);
<a name="l00567"></a>00567         <span class="keywordflow">for</span> (i = 0; i &lt; nsqr; i++) v[i] *= mult;
<a name="l00568"></a>00568     }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="comment">/* Clean up */</span>
<a name="l00571"></a>00571     Free(work); Free(scale); Free(perm); Free(npp); Free(dpp); Free(pivot);
<a name="l00572"></a>00572     UNPROTECT(1);
<a name="l00573"></a>00573     <span class="keywordflow">return</span> val;
<a name="l00574"></a>00574 }
<a name="l00575"></a>00575 
<a name="l00576"></a><a class="code" href="dgeMatrix_8h.html#adb4d1f7a285de0a6521f9d1846e12ed3">00576</a> SEXP <a class="code" href="dgeMatrix_8c.html#adb4d1f7a285de0a6521f9d1846e12ed3">dgeMatrix_Schur</a>(SEXP x, SEXP vectors)
<a name="l00577"></a>00577 {
<a name="l00578"></a>00578     <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00579"></a>00579     <span class="keywordtype">int</span> vecs = asLogical(vectors), info, izero = 0, lwork = -1, n = dims[0];
<a name="l00580"></a>00580     <span class="keywordtype">double</span> *work, tmp;
<a name="l00581"></a>00581     <span class="keyword">const</span> <span class="keywordtype">char</span> *nms[] = {<span class="stringliteral">&quot;WR&quot;</span>, <span class="stringliteral">&quot;WI&quot;</span>, <span class="stringliteral">&quot;T&quot;</span>, <span class="stringliteral">&quot;Z&quot;</span>, <span class="stringliteral">&quot;&quot;</span>};
<a name="l00582"></a>00582     SEXP val = PROTECT(<a class="code" href="Mutils_8h.html#a18ef7522c2488040a013971ad2dcb06c">Matrix_make_named</a>(VECSXP, nms));
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">if</span> (n != dims[1] || n &lt; 1)
<a name="l00585"></a>00585         error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_Schur: argument x must be a non-null square matrix&quot;</span>));
<a name="l00586"></a>00586     SET_VECTOR_ELT(val, 0, allocVector(REALSXP, n));
<a name="l00587"></a>00587     SET_VECTOR_ELT(val, 1, allocVector(REALSXP, n));
<a name="l00588"></a>00588     SET_VECTOR_ELT(val, 2, allocMatrix(REALSXP, n, n));
<a name="l00589"></a>00589     Memcpy(REAL(VECTOR_ELT(val, 2)), REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>)), n * n);
<a name="l00590"></a>00590     SET_VECTOR_ELT(val, 3, allocMatrix(REALSXP, vecs ? n : 0, vecs ? n : 0));
<a name="l00591"></a>00591     F77_CALL(dgees)(vecs ? <span class="stringliteral">&quot;V&quot;</span> : <span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, NULL, dims, (<span class="keywordtype">double</span> *) NULL, dims, &amp;izero,
<a name="l00592"></a>00592                     (<span class="keywordtype">double</span> *) NULL, (<span class="keywordtype">double</span> *) NULL, (<span class="keywordtype">double</span> *) NULL, dims,
<a name="l00593"></a>00593                     &amp;tmp, &amp;lwork, (<span class="keywordtype">int</span> *) NULL, &amp;info);
<a name="l00594"></a>00594     <span class="keywordflow">if</span> (info) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_Schur: first call to dgees failed&quot;</span>));
<a name="l00595"></a>00595     lwork = (int) tmp;
<a name="l00596"></a>00596     work = <a class="code" href="Mutils_8h.html#a679ceea530c97713d6abdb619e70a6b9">Alloca</a>(lwork, <span class="keywordtype">double</span>);
<a name="l00597"></a>00597     R_CheckStack();
<a name="l00598"></a>00598     F77_CALL(dgees)(vecs ? <span class="stringliteral">&quot;V&quot;</span> : <span class="stringliteral">&quot;N&quot;</span>, <span class="stringliteral">&quot;N&quot;</span>, NULL, dims, REAL(VECTOR_ELT(val, 2)), dims,
<a name="l00599"></a>00599                     &amp;izero, REAL(VECTOR_ELT(val, 0)), REAL(VECTOR_ELT(val, 1)),
<a name="l00600"></a>00600                     REAL(VECTOR_ELT(val, 3)), dims, work, &amp;lwork,
<a name="l00601"></a>00601                     (<span class="keywordtype">int</span> *) NULL, &amp;info);
<a name="l00602"></a>00602     <span class="keywordflow">if</span> (info) error(<a class="code" href="Mutils_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dgeMatrix_Schur: dgees returned code %d&quot;</span>), info);
<a name="l00603"></a>00603     UNPROTECT(1);
<a name="l00604"></a>00604     <span class="keywordflow">return</span> val;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a><a class="code" href="dgeMatrix_8h.html#a0b6c5f387f39437317fbfdd2b0a063a8">00607</a> SEXP <a class="code" href="dgeMatrix_8c.html#a0b6c5f387f39437317fbfdd2b0a063a8">dgeMatrix_colsums</a>(SEXP x, SEXP naRmP, SEXP cols, SEXP mean)
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609     <span class="keywordtype">int</span> keepNA = !asLogical(naRmP);
<a name="l00610"></a>00610     <span class="keywordtype">int</span> doMean = asLogical(mean);
<a name="l00611"></a>00611     <span class="keywordtype">int</span> useCols = asLogical(cols);
<a name="l00612"></a>00612     <span class="keywordtype">int</span> *dims = INTEGER(GET_SLOT(x, <a class="code" href="Syms_8h.html#a2b91d011a529c5665e032a6565275374">Matrix_DimSym</a>));
<a name="l00613"></a>00613     <span class="keywordtype">int</span> i, j, m = dims[0], n = dims[1];
<a name="l00614"></a>00614     SEXP ans = PROTECT(allocVector(REALSXP, (useCols) ? n : m));
<a name="l00615"></a>00615     <span class="keywordtype">double</span> *aa = REAL(ans), *xx = REAL(GET_SLOT(x, <a class="code" href="Syms_8h.html#a8e6ccf1b89de0c7d61722fd1579eb085">Matrix_xSym</a>));
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="keywordflow">if</span> (useCols) {  <span class="comment">/* col(Sums|Means) : */</span>
<a name="l00618"></a>00618         <span class="keywordtype">int</span> cnt = m;
<a name="l00619"></a>00619         <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l00620"></a>00620             <span class="keywordtype">double</span> *rx = xx + m * j;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622             aa[j] = 0;
<a name="l00623"></a>00623             <span class="keywordflow">if</span> (keepNA)
<a name="l00624"></a>00624                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) aa[j] += rx[i];
<a name="l00625"></a>00625             <span class="keywordflow">else</span> {
<a name="l00626"></a>00626                 cnt = 0;
<a name="l00627"></a>00627                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++)
<a name="l00628"></a>00628                     <span class="keywordflow">if</span> (!ISNAN(rx[i])) {cnt++; aa[j] += rx[i];}
<a name="l00629"></a>00629             }
<a name="l00630"></a>00630             <span class="keywordflow">if</span> (doMean) {
<a name="l00631"></a>00631                 <span class="keywordflow">if</span> (cnt &gt; 0) aa[j] /= cnt; <span class="keywordflow">else</span> aa[j] = NA_REAL;
<a name="l00632"></a>00632             }
<a name="l00633"></a>00633         }
<a name="l00634"></a>00634     } <span class="keywordflow">else</span> { <span class="comment">/* row(Sums|Means) : */</span>
<a name="l00635"></a>00635         <span class="keywordtype">double</span> *Count = ((!keepNA) &amp;&amp; doMean) ?
<a name="l00636"></a>00636             <a class="code" href="Mutils_8h.html#a679ceea530c97713d6abdb619e70a6b9">Alloca</a>(m, <span class="keywordtype">double</span>) : (<span class="keywordtype">double</span>*)NULL ;
<a name="l00637"></a>00637         R_CheckStack();
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) aa[i] = 0.0;
<a name="l00640"></a>00640         <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l00641"></a>00641             <span class="keywordflow">if</span> (keepNA)
<a name="l00642"></a>00642                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) aa[i] += xx[i + j * m];
<a name="l00643"></a>00643             <span class="keywordflow">else</span>
<a name="l00644"></a>00644                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) {
<a name="l00645"></a>00645                     <span class="keywordtype">double</span> el = xx[i + j * m];
<a name="l00646"></a>00646                     <span class="keywordflow">if</span> (!ISNAN(el)) {
<a name="l00647"></a>00647                         aa[i] += el;
<a name="l00648"></a>00648                         <span class="keywordflow">if</span> (doMean) Count[i]++;
<a name="l00649"></a>00649                     }
<a name="l00650"></a>00650                 }
<a name="l00651"></a>00651         }
<a name="l00652"></a>00652         <span class="keywordflow">if</span> (doMean) {
<a name="l00653"></a>00653             <span class="keywordflow">if</span> (keepNA)
<a name="l00654"></a>00654                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) aa[i] /= n;
<a name="l00655"></a>00655             <span class="keywordflow">else</span>
<a name="l00656"></a>00656                 <span class="keywordflow">for</span> (i = 0; i &lt; m; i++)
<a name="l00657"></a>00657                     aa[i] = (Count[i]&gt;0)? aa[i]/Count[i]: NA_REAL;
<a name="l00658"></a>00658         }
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     UNPROTECT(1);
<a name="l00662"></a>00662     <span class="keywordflow">return</span> ans;
<a name="l00663"></a>00663 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 11 2010 19:50:59 for Matrix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
