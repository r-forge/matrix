


testfun <- function(...) # test function
{
    ## simulation: 300 obs, 30 students, 10 obs per student, one covariate

    dat <- data.frame(id1 = gl(30, 10),
                      id2 = gl(60, 5),
                      x = rnorm(300))

    dat$resp <-
        with(dat,
             rbinom(300,
                    size = 1,
                    prob = binomial()$linkinv( x + rnorm(30, sd = .5)[id1])))


#    fm.GLMM <- GLMM(formula = resp ~ x, data = dat, family = binomial(), random = list(id = ~1))


    fm.sparse1 <-
        sparseGLMM(resp ~ x, data = dat, family = binomial(),
                   random = list(id1 = ~1, id2 = ~1),
                   control = lmeControl(EMverbose = F, ...))
    fm.sparse2 <-
        sparseGLMM(resp ~ x, data = dat, family = binomial(),
                   random = list(id2 = ~1, id1 = ~1),
                   control = lmeControl(EMverbose = F, ...))
    list(fm.sparse1, fm.sparse2)
}



testfun2 <- function(...)
{
    data(guImmun)
    fm1.gui <-
        sparseGLMM(immun ~ kid2p + mom25p + ord + ethn +
                   momEd + husEd + momWork + rural + pcInd81,
                   data = guImmun, family = binomial(),
                   random = list(mom = ~1, comm = ~1),
                   control = lmeControl(...))
    fm2.gui <-
        sparseGLMM(immun ~ kid2p + mom25p + ord + ethn +
                   momEd + husEd + momWork + rural + pcInd81,
                   data = guImmun, family = binomial(),
                   random = list(comm = ~1, mom = ~1),
                   control = lmeControl(...))
    list(fm1 = fm1.gui, fm2 = fm2.gui)
}    





setGeneric("sparseGLMM",
           function(formula, family, data, random,

                    subset, method, na.action, control, model, x, ...)

           standardGeneric("sparseGLMM"))



# if (!isGeneric("sparseGLMM")) {
#     setGeneric("sparseGLMM",
#                function(formula, family, data, random,

#                         control, niter, method, verbose, ...)


#                standardGeneric("sparseGLMM"))
# }






## lme for reference (remove later)

setMethod("sparseGLMM", signature(formula = "formula", family = "family", random = "list"),
          function(formula, family, data, random, subset,
                   method, na.action, control, model, x, ...)
      {





          debug <- FALSE ## check if fitted() works. Remove all such code later




          if (missing(model))
              model = TRUE
          if (missing(x))
              x = FALSE
          random = lapply(as(random, "list"),
                   get("formula", pos = parent.frame(), mode = "function"))
                   #lapply(random, function(x)
                          #if(inherits(x, "formula")) pdLogChol(x) else x)


          ## should actually be PQL, Laplace, etc in this context
          method = "ML"



          controlvals <- if (missing(control)) lmeControl() else
                            do.call("lmeControl", control)
          mCall <- match.call(expand.dots = FALSE)
          controlvals$REML <- method == "REML"

          mCall[[1]] <- as.name("model.frame")
          names(mCall)[2] <- "formula"
          mCall$family <- mCall$random <- mCall$method <-
              mCall$control <- mCall$model <- mCall$x <- NULL
          form <- formula
          form[[3]] <- (~a+b)[[2]]
          form[[3]][[2]] <- formula[[3]]
          form[[3]][[3]] <-
              as.formula((parse(text=paste("~",
                                paste(names(random),
                                      collapse = "+")))[[1]]))[[2]]
          for (pdm in random) {
              tmp <- form
              tmp[[3]] <- (~a+b)[[2]]
              tmp[[3]][[2]] <- form[[3]]
              tmp[[3]][[3]] <- formula(pdm)[[2]]
              form <- tmp
          }
          environment(form) <- environment(formula)
          mCall$formula <- form
          mCall$drop.unused.levels <- TRUE

          data <- eval(mCall, parent.frame())
          facs <- lapply(names(random),
                         function(x) eval(as.name(x), envir = data))
          names(facs) <- names(random)

          ## creates model matrices
          mmats.unadjusted <-
              c(lapply(random,
                       function(x) model.matrix(formula(x), data = data)),
                list(.Xy =
                     cbind(model.matrix(formula, data = data),
                           .response = model.response(data))))
          responseIndex <- ncol(mmats.unadjusted$.Xy)


          ## creates ssclme structure
          obj <- .Call("ssclme_create", facs, unlist(lapply(mmats.unadjusted, ncol)),
                       as.integer(2e5), PACKAGE = "Matrix")


          ## FIXME: names of facs lost, but may be useful later
          facs = facshuffle(obj, facs)
          names(facs) = names(random)

          obj = obj[[1]]
          ##.Call("ssclme_initial", obj, PACKAGE="Matrix")


          ## get initial estimates
          fm.glm <- glm(formula, family, data)
          coefFixef <- c(coef(fm.glm), 0)


          if (debug)
          {
              coefRanef <-
                  lapply(facs,
                         function(x) numeric(nlevels(x)))
              for (facname in names(facs))
              {
                  coefRanef[[facname]] <-
                      matrix(rep(coefRanef[[facname]], ncol(mmats.unadjusted[[facname]])),
                             ncol = ncol(mmats.unadjusted[[facname]]))
              }
          }


          mmats <- mmats.unadjusted
          conv <- FALSE
          firstIter <- TRUE



          ## initial 'fitted' values on linear scale
          eta <- drop(mmats.unadjusted$.Xy %*% coefFixef)
          etaold <- eta

#print(str(mmats.unadjusted))
          for (iter in seq(length = controlvals$glmmMaxIter))
          {

cat(paste("\n\n\nIteration", iter, "\n"))



              if (debug)
              {
                  eta.check <- mmats.unadjusted$.Xy %*% coefFixef
                  for (facname in names(facs))
                  {
                      eta.check <- eta.check +
                          mmats.unadjusted[[facname]] * coefRanef[[facname]][facs[[facname]],]
                  }
                  eta.check <- drop(eta.check)


                  if (!is.logical(all.equal(eta.check, eta))) {
                      warning("fitted() does not match calculation, diff: ",
                              sum(((eta.check - eta)^2)))
                  }
                  else print("fitted values match")
                  #eta <- drop(eta.check)
              }


              mu <- family$linkinv(eta)
              dmu.deta <- family$mu.eta(eta)
              ## adjusted response
              z <- eta + (mmats.unadjusted$.Xy[, responseIndex] - mu) / dmu.deta
              ## weights
              w <- dmu.deta / sqrt(family$variance(mu))
#w <- 1#rep(c(.9, 1.1), length = length(w))
print(summary(w))
#plot(z, mmats$.Xy[, responseIndex])

              ## Does this prevent overwriting of components ?
              for (facname in names(facs))
                  mmats[[facname]][] <- mmats.unadjusted[[facname]] * w
              mmats$.Xy[] <- mmats.unadjusted$.Xy
              mmats$.Xy[, responseIndex] <- z
              mmats$.Xy[] <- mmats$.Xy * w





#print(summary(data.frame(eta = eta, z, w, zw = z * w)))
              .Call("ssclme_update_mm", obj, facs, mmats, PACKAGE="Matrix")
return(obj)
## ssclme_initial should only be called on the first iteration
              if (firstIter) .Call("ssclme_initial", obj, PACKAGE="Matrix")
print(3)
print(str(obj@Omega))
              .Call("ssclme_EMsteps", obj, controlvals$niterEM,
                    method == "REML", controlvals$EMverbose, PACKAGE = "Matrix")
              LMEoptimize(obj) = controlvals
              eta[] <- .Call("ssclme_fitted", obj, facs, mmats.unadjusted, PACKAGE = "Matrix")


print(max(abs(eta - etaold)) / (0.1 + max(abs(eta))))

              ## use this to determine convergence
              if (max(abs(eta - etaold)) < (0.1 + max(abs(eta))) * controlvals$tolerance)
              {
                  conv <- TRUE
                  break
              }
              etaold[] <- eta





              if (debug)
              {
                  coefFixef <- c(fixef(obj), 0)
                  coefRanef <- ranef(obj)
              }



### May want to adjust number of EMiterations on second and subsequent
### iterations.  Probably one or two iterations will suffice

### Do you want to call LMEoptimize(obj) = controlvals here?  Probably
### set number of iterations low.

              if (firstIter) {
                  controlvals$niterEM <- 2
                  controlvals$msMaxIter <- 10
                  firstIter <- FALSE
              }

          }
          if (!conv) warning("IRLS iterations for glmm did not converge")

          new("lme", call = match.call(), facs = facs,
              x = if(x) mmats else list(),
              model = if(model) data else data.frame(list()),
              REML = method == "REML", rep = obj, fitted = eta)
      })











## what happens in glm.fit:


#             eta <- drop(x %*% start)
#             mu <- linkinv(eta <- eta + offset)
#             dev <- sum(dev.resids(y, mu, weights))
#             if (control$trace)
#                 cat("Deviance =", dev, "Iterations -", iter, "\n")



#             ## check for divergence
#             boundary <- FALSE
#             if (!is.finite(dev)) {
#                 if(is.null(coefold))
#                     stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
#                 warning("Step size truncated due to divergence", call. = FALSE)
#                 ii <- 1
#                 while (!is.finite(dev)) {
#                     if (ii > control$maxit)
#                         stop("inner loop 1; can't correct step size")
#                     ii <- ii + 1
#                     start <- (start + coefold)/2
#                     eta <- drop(x %*% start)
#                     mu <- linkinv(eta <- eta + offset)
#                     dev <- sum(dev.resids(y, mu, weights))
#                 }
#                 boundary <- TRUE
#                 if (control$trace)
#                     cat("Step halved: new deviance =", dev, "\n")
#             }



#             ## check for fitted values outside domain.
#             if (!(valideta(eta) && validmu(mu))) {
#                 warning("Step size truncated: out of bounds", call. = FALSE)
#                 ii <- 1
#                 while (!(valideta(eta) && validmu(mu))) {
#                     if (ii > control$maxit)
#                         stop("inner loop 2; can't correct step size")
#                     ii <- ii + 1
#                     start <- (start + coefold)/2
#                     eta <- drop(x %*% start)
#                     mu <- linkinv(eta <- eta + offset)
#                 }
#                 boundary <- TRUE
#                 dev <- sum(dev.resids(y, mu, weights))
#                 if (control$trace)
#                     cat("Step halved: new deviance =", dev, "\n")
#             }




#             ## check for convergence
#             if (abs(dev - devold)/(0.1 + abs(dev)) < control$epsilon) {
#                 conv <- TRUE
#                 coef <- start
#                 break
#             } else {
#                 devold <- dev
#                 coef <- coefold <- start
#             }
#         } ##-------------- end IRLS iteration -------------------------------

#         if (!conv) warning("Algorithm did not converge")
#         if (boundary) warning("Algorithm stopped at boundary value")
#         eps <- 10*.Machine$double.eps
#         if (family$family == "binomial") {
#             if (any(mu > 1 - eps) || any(mu < eps))
#                 warning("fitted probabilities numerically 0 or 1 occurred")
#         }
#         if (family$family == "poisson") {
#             if (any(mu < eps))
#                 warning("fitted rates numerically 0 occurred")
#         }
#         ## If X matrix was not full rank then columns were pivoted,
#         ## hence we need to re-label the names ...
#         ## Original code changed as suggested by BDR---give NA rather
#         ## than 0 for non-estimable parameters
#         if (fit$rank < nvars) coef[fit$pivot][seq(fit$rank+1, nvars)] <- NA
#         xxnames <- xnames[fit$pivot]
#         residuals <- rep.int(NA, nobs)
#         residuals[good] <- z - (eta - offset)[good] # z does not have offset in.
#         fit$qr <- as.matrix(fit$qr)
#         nr <- min(sum(good), nvars)
#         if (nr < nvars) {
#             Rmat <- diag(nvars)
#             Rmat[1:nr, 1:nvars] <- fit$qr[1:nr, 1:nvars]
#         }
#         else Rmat <- fit$qr[1:nvars, 1:nvars]
#         Rmat <- as.matrix(Rmat)
#         Rmat[row(Rmat) > col(Rmat)] <- 0
#         names(coef) <- xnames
#         colnames(fit$qr) <- xxnames
#         dimnames(Rmat) <- list(xxnames, xxnames)


















### Local variables:
### mode: R
### End:
